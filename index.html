\<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Squad Vault</title>
  <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@1/lib/index.iife.min.js"></script>
  <style>
    /* same styles as before */
  </style>
</head>
<body>
  <canvas id="rain-canvas"></canvas>

  <div id="content">
    <h1>The Squad Vault</h1>
    <p>Squad USDC vault for the chat. Send via wallet</p>

    <p>Vault Address: <code id="address">Loading...</code></p>

    <div id="balance">Vault Size: Loading... USDC</div>

    <div id="recent">
      <h2>Recent Deposits</h2>
      <ul id="txList"><li>Loading...</li></ul>
    </div>
  </div>

  <script>
    // Matrix Rain (same as before)
    // ... (unchanged rain code)

    // Vault Functionality with fallback RPCs + retry
    const walletAddress = "2etUEjDx6BuRpC1fSKf2uFVReR9jCZ5QaF3hUABp1mc1";

    document.getElementById("address").textContent = walletAddress;

    const RPCS = [
      "https://rpc.ankr.com/solana",
      "https://solana-api.projectserum.com",
      "https://api.mainnet-beta.solana.com"
    ];
    let currentRpcIndex = 0;

    function getConnection() {
      return new solanaWeb3.Connection(RPCS[currentRpcIndex]);
    }

    const USDC_MINT = new solanaWeb3.PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");

    let usdcTokenAccount = null;

    async function updateVault() {
      try {
        let connection = getConnection();

        if (!usdcTokenAccount) {
          const tokenAccounts = await connection.getTokenAccountsByOwner(new solanaWeb3.PublicKey(walletAddress), { mint: USDC_MINT });
          if (tokenAccounts.value.length > 0) usdcTokenAccount = tokenAccounts.value[0].pubkey;
        }

        let balance = 0;
        if (usdcTokenAccount) {
          const info = await connection.getTokenAccountBalance(usdcTokenAccount);
          balance = parseFloat(info.value.uiAmount || 0);
        }
        document.getElementById("balance").textContent = `Vault Size: ${balance.toFixed(2)} USDC`;

        const txList = document.getElementById("txList");
        txList.innerHTML = "";
        if (!usdcTokenAccount) {
          txList.innerHTML = "<li>No USDC account detected yet.</li>";
          return;
        }
        const signatures = await connection.getSignaturesForAddress(usdcTokenAccount, { limit: 20 });
        if (signatures.length === 0) {
          txList.innerHTML = "<li>No deposits yet.</li>";
          return;
        }
        for (const sigInfo of signatures) {
          const tx = await connection.getParsedTransaction(sigInfo.signature, { maxSupportedTransactionVersion: 0 });
          if (!tx) continue;

          let change = 0;
          const pre = tx.meta.preTokenBalances.find(b => b.accountIndex === tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toBase58() === usdcTokenAccount.toBase58()));
          const post = tx.meta.postTokenBalances.find(b => b.accountIndex === tx.transaction.message.accountKeys.findIndex(k => k.pubkey.toBase58() === usdcTokenAccount.toBase58()));
          if (pre && post && post.uiTokenAmount.uiAmount > pre.uiTokenAmount.uiAmount) {
            change = post.uiTokenAmount.uiAmount - pre.uiTokenAmount.uiAmount;
          }
          if (change <= 0) continue;

          let memo = '';
          const instructions = tx.transaction.message.instructions;
          for (const ix of instructions) {
            if (ix.programId.toBase58() === "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr") {
              try {
                memo = atob(ix.data).trim();
                if (memo.length > 100) memo = memo.substring(0, 100) + '...';
              } catch {}
              break;
            }
          }

          const li = document.createElement("li");
          li.textContent = `+${change.toFixed(2)} USDC ${memo ? ` - "${memo}"` : ' (anonymous)'}`;
          txList.appendChild(li);
        }
      } catch (e) {
        console.error(e);
        currentRpcIndex = (currentRpcIndex + 1) % RPCS.length; // Switch RPC on error
        document.getElementById("balance").textContent = "Vault Size: Loading... (retrying)";
        setTimeout(updateVault, 5000); // Retry sooner on error
      }
    }
    updateVault();
    setInterval(updateVault, 15000);
  </script>
</body>
</html>